<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>dm.js - dm</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <style type="text/css">

    </style>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1>dm</h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/DM.html">DM</a></li>
            
                <li><a href="../classes/DMExec.html">DMExec</a></li>
            
                <li><a href="../classes/DMModule.html">DMModule</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/dm.html">dm</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: dm.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * DOM Markers
 *
 * @module dm
 */

//TODO - outer dependencies support (addDep, removeDep, getDep)
//TODO - implement registry retrieving (for debug)
var DMUtils = {
    /**
     * Each utility function
     * @param {Object} obj
     * @param {Function} callback
     * @param {Object?} context
     */
    each : function(obj, callback, context){
        var i;

        for (i in obj) {
            if (obj.hasOwnProperty(i)) {
                callback.call(context, obj[i], i, obj);
            }
        }
    },

    /**
     * Map utility function
     * @param {Array} arr
     * @param {Function} callback
     * @param {*?} context
     * @returns {*}
     */
    map : function(arr, callback, context){
        return arr.map(callback, context);
    },

    /**
     * @param {String} selector
     * @param {Element|HTMLDocument|?} ctx
     * @returns {NodeList}
     */
    all : function(selector, ctx){
        if (!(ctx instanceof Element || ctx instanceof HTMLDocument)) {
            ctx = document;
        }

        return ctx.querySelectorAll(selector);
    },

    /**
     * Trim
     * @param {string} str
     * @returns {string}
     */
    trim : function(str){
        return str.trim();
    },

    /**
     *
     * @param {Element} node
     * @param {string} attrName
     * @return {Array.&lt;{name:String,args:Array}&gt;}
     */
    getModules : function(node, attrName){
        return DMUtils.map(node.getAttribute(attrName).match(/([a-zA-Z][a-zA-Z\-0-9]*(\[[^[]+\])?)/ig) || [], function(str){
            var parts = str.match(/[^\[\]]+/ig),
                name,
                args;

            name = parts.shift();
            //todo - parse json hash
            args = parts[0] ? DMUtils.map(parts[0].split(&#x27;,&#x27;), DMUtils.trim) : [];

            //convert arguments to native types
            DMUtils.each(args, function(value, key, data){
                if (value === &#x27;false&#x27;) {
                    data[key] = !1;
                }
                else if (value === &#x27;true&#x27;) {
                    data[key] = !0;
                }
                else if (value == parseFloat(value)) {
                    data[key] = parseFloat(value);
                }
                else if (value === &#x27;null&#x27;) {
                    data[key] = null;
                }
            });

            return {
                name : name,
                args : args
            };
        });
    },

    /**
     * Filter utility function
     * @param arr
     * @param callback
     * @returns {*}
     */
    filter : function(arr, callback){
        return arr.filter(callback);
    },

    /**
     * Filter modules (exclude already executed on node)
     * @param {Element} node
     * @param {Array} list
     * @param {Object} modules
     * @returns {*}
     */
    filterModules : function(node, list, modules){
        return DMUtils.filter(list, function(module){
            var _data = node._dm || (node._dm = {}),
                uuid,
                result = false;

            //should set result to true, if module where not processed for this node
            uuid = modules[module.name] &amp;&amp; modules[module.name].uuid;

            if (!_data[uuid]) {
                result = _data[uuid] = true;
            }

            return result;
        });
    },

    updateNodeState : function(node, module, modules, state){
        var data,
            uuid,
            result;

        data = node._dm || (node._dm = {});
        uuid = modules[module.name] &amp;&amp; modules[module.name].uuid;

        result = data[uuid] || 1;

        data[uuid] = state || result;

        /*if (module.name === &#x27;B&#x27;) {
         debugger;
         }*/

        return result !== state;
    },

    shouldProcessNode : function(node, module, modules){
        var data,
            uuid,
            result;

        data = node._dm || (node._dm = {});
        uuid = modules[module.name] &amp;&amp; modules[module.name].uuid;

        if (!data[uuid]) {
            result = data[uuid] = 1;
        }
        else {
            result = data[uuid];
        }

        return result;
    },

    /*    isEmpty : function(object) {
     var i;//todo - probably should use some other way here
     for(i in object) {
     if (object.hasOwnProperty(i)) {
     return false;
     }
     }
     return true;
     },*/

    keysCount : function(object){
        var i;//todo - probably should use some other way here
        for (i in object) {
            if (object.hasOwnProperty(i)) {
                i++;
            }
        }
        return i;
    },

    /**
     * InSort sorting implementation
     * @note Used cause of unstable native algorithm of Chrome
     * @param {Function?} fn
     * @returns {Array}
     */
    inSort : function inSort(fn){
        var i, n, j, key;
        for (i = 1, n = this.length; i &lt; n; i++) {
            key = this[i];
            j = i - 1;

            while (j &gt;= 0 &amp;&amp; fn ? fn(this[j], key) &gt; 0 : this[j] &gt; key) {
                this[j + 1] = this[j];
                j = j - 1;
            }

            this[j + 1] = key
        }
        return this;
    },

    /**
     * Return new unique id
     * @returns {Function}
     */
    uuid : (function(){
        var uuid = 0;
        return function(){
            return ++uuid;
        };
    })()
};

/**
 * Module constructor
 *
 * @param {string} name - name of the module
 * @param {Function?} callback - main module callback
 * @param {Array.&lt;string&gt;?} dependency - an array of modules names from which this depends
 * @constructor
 * @class DMModule
 */
function DMModule(name, callback, dependency){
    this.uuid = DMUtils.uuid();
    this.name = name;
    this.ready = false;
    this.data = {};

    this._dependency = [];
    this._before = [];
    this._after = [];
    this._instances = [];
    this._add = callback;

    DMUtils.each(dependency, function(name) {
        this._dependency.push({
            name      : name,
            data      : null,
            instances : []
        });
    }, this);
}

/**
 * Sort module
 *
 * @param {Array} arr
 * @returns {DMModule}
 * @private
 * @method _sort
 * @chainable
 */
DMModule.prototype._sort = function(arr){
    arr.sort(function(a, b){
        var result;

        if (a.weight === b.weight) {
            result = 0;//todo - check that the native sort works correctly when arr.length &gt; 10
        }
        else {
            result = a.weight &gt; b.weight ? 1 : -1;
        }

        return result;
    });
    return this;
};

/**
 * Preparation method (before execution)
 *
 * @returns {this}
 * @private
 * @method _prepare
 * @chainable
 */
DMModule.prototype._prepare = function(){
    this._sort(this._before)._sort(this._after);
    this.ready = true;
    return this;
};

/**
 * Add &#x60;_before&#x60; callback to module
 *
 * Used by &#x60;DM.before&#x60;
 *
 * **internal use only**
 *
 * @param {Function} callback
 * @param {Number?} weight
 * @returns {Number}
 * @protected
 * @method before
 */
DMModule.prototype.before = function(callback, weight){
    var id = DMUtils.uuid();

    this.ready = false;

    this._before.push({
        callback : callback,
        weight   : weight || 0,
        uuid     : id
    });

    return id;
};

/**
 * Add &#x60;_after&#x60; callback to module
 *
 * Used by &#x60;DM.after&#x60;
 *
 * **internal use only**
 *
 * @param {Function} callback
 * @param {Number?} weight
 * @returns {Number}
 * @protected
 * @method after
 */
DMModule.prototype.after = function(callback, weight){
    var id = DMUtils.uuid();

    this.ready = false;

    this._after.push({
        callback : callback,
        weight   : weight || 0,
        uuid     : id
    });

    return id;
};

/**
 * Constructor of execution manager
 *
 * Used as &#x60;this&#x60; context for the all &#x60;(add, before, after)&#x60; execution callbacks
 *
 * @param {DMModule} module
 * @param {Object} inst - {node:Element, args:Array, data: *}
 * @param {Function} finish - execution finish callback
 * @constructor
 * @class DMExec
 */
function DMExec(module, inst, finish){
    this.module = module;
    this.node = inst.node;
    this.args = inst.args;
    this.data = inst.data;

    this._state = 0;
    this._index = 0;
    this._waiting = null;
    this._finish = finish;
    this._timer = null;

    this._execute();
}

/**
 * Internal execution states;
 *
 * **internal use only**
 *
 * - &#x60;INITIAL&#x60; - initial state
 * - &#x60;BEFORE&#x60; - execution of _before_ callbacks
 * - &#x60;MAIN&#x60; - execution of _add_ callback
 * - &#x60;AFTER&#x60; - execution of _after_ callbacks
 * - &#x60;FINISHED&#x60; - finished state
 *
 * @type {{INITIAL: number, BEFORE: number, MAIN: number, AFTER: number, FINISHED: number}}
 * @property STATES
 * @static
 */
DMExec.STATES = {
    INITIAL  : 0,
    BEFORE   : 1,
    MAIN     : 2,
    AFTER    : 3,
    FINISHED : 4
};

/**
 * Execution types
 *
 * **internal use only**
 *
 * @type {{NEXT: string, STOP: string}}
 * @property TYPES
 * @static
 */
DMExec.TYPES = {
    NEXT : &#x27;next&#x27;,
    STOP : &#x27;stop&#x27;
};

/**
 * Force current execution manager instance to execute next callback
 *
 * @method next
 */
DMExec.prototype.next = function(){
    if (this._waiting) {
        this._waiting = false;
        clearTimeout(this._timer);
    }
    this._index++;
    this._execute(DMExec.TYPES.NEXT);
    //todo - should we stop any other code below the next call ?
};
/**
 * Stops current execution
 *
 * @method stop
 */
DMExec.prototype.stop = function(){
    if (this._waiting) {
        this._waiting = false;
        clearTimeout(this._timer);
    }
    this._index = 0;
    this._state = DMExec.STATES.FINISHED;
    this._execute(DMExec.TYPES.STOP);
};
/**
 * Proceed callback execution
 *
 * **internal use only**
 *
 * @param {String?} type
 * @method _execute
 * @returns {DMExec}
 * @protected
 */
DMExec.prototype._execute = function(type){
    var states = DMExec.STATES,
        types = DMExec.TYPES,
        module = this.module,
        obj;

    if (!(type === types.NEXT &amp;&amp; this._state === states.INITIAL)) {
        if (!module.ready) {
            module._prepare();
        }
    }

    if (this._state === states.INITIAL) {
        this._state = states.BEFORE;
    }

    //noinspection FallthroughInSwitchStatementJS
    switch (this._state) {
        case states.BEFORE:
        case states.AFTER:
            obj = module[this._state === states.BEFORE ? &#x27;_before&#x27; : &#x27;_after&#x27;][this._index];

            if (obj &amp;&amp; typeof obj.callback === &#x27;function&#x27;) {
                obj.callback.apply(this, this.args);
            }
            else {
                this._state = this._state === states.BEFORE ? states.MAIN : states.FINISHED;
                this._index = -1;
            }
            break;
        case states.MAIN:
            //the 2 lines of code below fix isn&#x27;t so actually good.
            this._state = states.AFTER;
            this._index = -1;
            //todo - should provide correct state &amp; index properties inside current execution context
            if (typeof module._add === &#x27;function&#x27;) {
                module._add.apply(this, this.args);
            }
            break;
        case states.FINISHED:
            this._state = states.INITIAL;
            this._index = 0;

            if (typeof this._finish === &#x27;function&#x27;) {
                this._finish.call(this);
            }
            break;
        default:
    }

    if (this._state !== states.INITIAL &amp;&amp; !this._waiting) {
        this.next();
    }

    return this;
};

/**
 * Initiate execution timeout
 *
 * @param {number?} timeout - wait timeout in ms; &#x60;default: 5000&#x60;
 * @param {boolean?} stop - will abort execution if timeout reached &amp; value is true; &#x60;default: false&#x60;
 * @method wait
 */
DMExec.prototype.wait = function(timeout, stop){
    var self = this;

    this._waiting = true;

    this._timer = setTimeout(function(){
        self[stop ? &#x27;stop&#x27; : &#x27;next&#x27;]();
    }, timeout || 5000);
};

/**
 * Return children elements data
 *
 * Structure:
 *
 *     Object {
 *         module_name : Array.&lt;
 *             {
 *                 node : Element
 *                 args : Array
 *             }
 *         &gt;,
 *         ...
 *     }
 *
 * @returns {Object}
 * @method children
 */
DMExec.prototype.children = function(){
    //todo - should accept role
    //todo - should cache
    var attrName,
        nodes,
        result = {};

    attrName = DM.config(&#x27;prefix&#x27;) + this.module.name;
    nodes = DMUtils.all(&#x27;[&#x27; + attrName + &#x27;]&#x27;, this.node);

    DMUtils.each(Array.prototype.slice.call(nodes), function(node){
        DMUtils.each(DMUtils.getModules(node, attrName), function(module){
            if (!result[module.name]) {
                result[module.name] = [];
            }
            result[module.name].push({
                node : node,
                args : module.args
            });
        });
    }, this);

    return result;
};

/**
 * Return dependency information
 *
 * Structure:
 *
 *     Object {
 *         name : String - name of the module
 *         data : * - Global (per module) execution context (mixed data)
 *         instances: Array.&lt;
 *             {
 *                 node : Element
 *                 args : Array
 *                 data : *
 *             }
 *         &gt;
 *     }
 *
 *
 * @param {string} name
 * @returns {Object?}
 * @method dependency
 */
DMExec.prototype.dependency = function(name){
    var i, l, dependencies, result;

    dependencies = this.module._dependency;

    for(i = 0, l = dependencies.length; i &lt; l; i++) {
        if (dependencies[i].name === name ) {
            result = dependencies[i];
            break;
        }
    }
    return result;
};

/**
 * Main library wrapper
 *
 * @class DM
 */
var DM = (function(options){
    var _modules = {},
        _engine,
        _bind = {},
        _config_default = {
            attr   : &#x27;data-marker&#x27;,
            prefix : &#x27;data-&#x27;
        },
        _config = {
            attr   : _config_default.attr,
            prefix : _config_default.prefix
        };

    function initEngine(callback){
        if (!_engine) {
            if (options.engines.y) {
                //_engine = options.engines.y;
                options.engines.y().use(&#x27;node-base&#x27;, &#x27;array-extras&#x27;, function(Y){
                    DMUtils.all = function(selector, ctx){
                        return (ctx ? Y.one(ctx) : Y).all(selector).getDOMNodes();
                    };

                    DMUtils.map = function(arr, callback, context){
                        return Y.Array.map(arr, callback, context);
                    };

                    DMUtils.filter = function(arr, callback){
                        return Y.Array.filter(arr, callback);
                    };

                    DMUtils.trim = function(str){
                        return Y.Lang.trim(str);
                    };

                    _engine = Y;

                    callback();
                });
            } else if (options.engines.j) {
                _engine = options.engines.j;

                DMUtils.all = function(selector, ctx){
                    return Array.prototype.slice.call(_engine(selector, ctx));
                };

                DMUtils.map = function(arr, callback, context){
                    //todo - use context
                    return _engine.map(arr, callback);
                };

                DMUtils.filter = function(arr, callback){
                    return _engine.grep(arr, callback);
                };

                DMUtils.trim = function(str){
                    return _engine.trim(str);
                };

                callback();
            }
            else {
                _engine = true;
                callback();
            }
        }
        else {
            callback();
        }
    }

    /**
     * Create new {DMModule} instance
     * @param {string} name
     * @param {Function?} callback
     * @param {Array.&lt;string&gt;?} dependency
     * @returns {DMModule}
     */
    function createModule(name, callback, dependency){
        return _modules[name] = new DMModule(name, callback, dependency);
    }

    /**
     * Get existing module or false
     * @param {String} name
     * @returns {DMModule|Boolean}
     */
    function getModule(name){
        var module = _modules[name];

        //todo - thrown an error if module was not found

        return module instanceof DMModule ? module : false;
    }

    function onFinish(dependancies, listener) {
        DMUtils.each(dependancies, function(dep) {
            if (!_bind[dep.name]) {
                _bind[dep.name] = {}
            }
            _bind[dep.name][listener.name] = listener;
        });
    }

    function executeModule(module, cb) {
        DMUtils.each(module._instances, function(inst) {
            if (DMUtils.updateNodeState(inst.node, module, _modules, 2)) {
                //update dependencies
                DMUtils.each(module._dependency, function(dep){
                    var mod = getModule(dep.name);
                    dep.instances = mod._instances;
                    dep.data = mod.data;
                });

                new DMExec(module, inst, cb);
            }
        });
    }

    return {
        /**
         * Declare DM module
         *
         * @param {String} name - name of the module
         * @param {Function?} callback - the module body function
         * @param {Array.&lt;string&gt;?} dependency - an array of modules names from which this depends
         * @returns {Number} - UUID of the callback
         * @static
         * @method add
         * @throws Error - if the module already declared
         */
        add : function(name, callback, dependency){
            var module = getModule(name);
            if (module) {
                if (typeof module._add === &#x27;function&#x27;) {
                    throw new Error(&#x27;Module(&#x27; + name + &#x27;) main callback is already defined&#x27;);
                }
                else {
                    module._add = callback;
                }
            }
            else {
                module = createModule(name, callback, dependency);
            }

            return module.uuid;
        },

        /**
         * Declare the callback preceding the module body function
         *
         * If the module weren&#x27;t created by &#x60;DM.add&#x60;: new module (without the body) will be created implicitly
         *
         * @param {String} name - name of the module
         * @param {Function} callback - the module preceding function
         * @param {Number?} weight - the weight of the callback (lower have the bigger priority)
         * @returns {Number} - UUID of the callback
         * @static
         * @method before
         * @throws Error - if the callback attribute is not a function
         */
        before : function(name, callback, weight){
            var module = getModule(name) || createModule(name);

            if (typeof callback !== &#x27;function&#x27;) {
                throw new Error(&#x27;Callback should be a function&#x27;);
            }

            return module.before(callback, weight);
        },

        /**
         * Declare the callback succeeding the module body function
         *
         * @param {String} name - name of the module
         * @param {Function} callback - the module succeeding function
         * @param {Number?} weight - the weight of the callback (lower have the bigger priority)
         * @returns {Number} - UUID of the callback
         * @static
         * @method after
         * @throws Error - if the callback attribute is not a function
         */
        after : function(name, callback, weight){
            var module = getModule(name) || createModule(name);

            if (typeof callback !== &#x27;function&#x27;) {
                throw new Error(&#x27;Callback should be a function&#x27;);
            }

            return module.after(callback, weight);
        },

        /**
         * Initiate callbacks execution
         *
         * @returns {DM}
         * @static
         * @method go
         * @chainable
         */
        go : function(){
            //todo - should accept &amp; execute only asked module(s): Array.&lt;string&gt;
            initEngine(function(){
                var ATTR = DM.config(&#x27;attr&#x27;),
                    nodes = DMUtils.all(&#x27;[&#x27; + ATTR + &#x27;]&#x27;, options.env.document);

                DMUtils.each(Array.prototype.slice.call(nodes), function(node){
                    var modules = DMUtils.getModules(node, ATTR);

                    DMUtils.each(modules, function(data){
                        var module = getModule(data.name);
                        if (module &amp;&amp; DMUtils.updateNodeState(node, module, _modules)) {
                            module._instances.push({
                                node : node,
                                args : data.args,
                                data : {}
                            });
                        }
                    });
                });

                var executed = [];

                var finishCallback = function(){
                    executed.push(this.module.name);

                    if (_bind[this.module.name]) {
                        DMUtils.each(_bind[this.module.name], function(module){
                            var ec = 0;

                            DMUtils.each(module._dependency, function(dep){
                                if (~executed.indexOf(dep.name)) {
                                    ec++;
                                }
                            });

                            if (module._dependency.length === ec) {
                                executeModule(module, finishCallback);
                            }

                            _bind[this.module.name] = null;
                            delete _bind[this.module.name];
                        }, this);
                    }
                };

                DMUtils.each(_modules, function(module){
                    if (module._dependency.length === 0) {
                        executeModule(module, finishCallback);
                    }
                    else {
                        onFinish(module._dependency, module);
                    }
                });
            });
            return this;
        },

        /**
         * Detach the callback
         *
         * @param {Number} uuid - UUID of the callback
         * @return {DM}
         * @static
         * @method detach
         * @chainable
         */
        detach : function(uuid){
            var name,
                i,
                obj,
                module,
                found = false;

            //check all the modules
            //try to find uuid in module or inside the before/afters
            for (name in _modules) {
                if (_modules.hasOwnProperty(name)) {
                    module = _modules[name];

                    if (module.uuid === uuid) {
                        //remove _add c/c
                        module._add = null;
                        found = true;
                    }
                    else {
                        for (i in module._before) {
                            if (module._before.hasOwnProperty(i)) {
                                obj = module._before[i];
                                if (obj.uuid === uuid) {
                                    module._before.splice(i, 1);
                                    found = true;
                                    break;
                                }
                            }
                        }

                        if (!found) {
                            for (i in module._after) {
                                if (module._after.hasOwnProperty(i)) {
                                    obj = module._after[i];
                                    if (obj.uuid === uuid) {
                                        module._after.splice(i, 1);
                                        found = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    if (found) {
                        break;
                    }
                }
            }
            return this;
        },

        /**
         * Remove module from registry
         *
         * @param {string} name - module name
         * @return {DM}
         * @static
         * @method remove
         * @chainable
         */
        remove : function(name){
            if (_modules[name]) {
                delete _modules[name];
            }
            return this;
        },

        /**
         * Remove all modules from registry
         *
         * @returns {DM}
         * @static
         * @method removeAll
         * @chainable
         */
        removeAll : function(){
            _modules = {};
            return this;
        },

        /**
         * Configuration getter/getter
         *
         * Currently available configuration keys: attr, prefix
         *
         * - Getting the current value, call this with the only one string parameter:
         *   _name_ of the configuration property
         * - Set the single value &#x60;DM.config(string_name, string_value)&#x60;
         * - Set any number of values &#x60;DM.config(Object.&lt;key:value&gt;)&#x60;
         *
         * @param {string|Object} cfg
         * @param {string?} value
         * @returns {string?} - current configuration value (&#x60;DM.config(string_value)
         * @static
         * @method config
         */
        config : function(cfg, value){
            var result, i;

            if (typeof cfg === &#x27;string&#x27;) {
                if (cfg in _config) {
                    if (typeof value === &#x27;string&#x27;) {
                        _config[cfg] = value;
                    }
                    else {
                        result = _config[cfg];
                    }
                }
            }
            else if (typeof cfg === &#x27;object&#x27;) {
                for (i in cfg) {
                    if (cfg.hasOwnProperty(i) &amp;&amp; i in _config &amp;&amp; typeof cfg[i] === &#x27;string&#x27;) {
                        _config[i] = cfg[i];
                    }
                }
            }

            return result;
        },

        /**
         * Revert inner configuration to default values
         *
         * @returns {DM}
         * @static
         * @method resetConfig
         * @chainable
         */
        resetConfig : function(){
            _config = {
                attr   : _config_default.attr,
                prefix : _config_default.prefix
            };

            return this;
        }
    };
})({
    env     : {
        win      : typeof window !== &#x27;undefined&#x27; &amp;&amp; window,
        document : typeof document !== &#x27;undefined&#x27; &amp;&amp; document
    },
    engines : {
        j : typeof jQuery === &#x27;function&#x27; &amp;&amp; jQuery,
        y : typeof YUI === &#x27;function&#x27; &amp;&amp; YUI
    }
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
